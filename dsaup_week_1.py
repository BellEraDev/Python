# -*- coding: utf-8 -*-
"""DSAUP Week 1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Hh3qvoS-OcHmYCrKqUcRMsVN5VBEbQmT

# Data Structures and Algorithms using Python

### Welcome to the new series!  We will be working through a new open source textbook using the Runscape Interactive platform, which allows for free and open access to the textbook and in-text exercises. Another user has also created a series of companion YouTube videos, if you find videos helpful. To facilitate distance learning, PyLadiesATX and Women Who Code Austin have created our own course, which you must log in to access.  
1. Follow the link to the Runestone interactive login page - https://runestone.academy/
2. Select the blue Sign Up button on the top left of the page
3. Create a profile, using `plwwc` as the course name. 

### Keep your account info handy, as you will need your login to access the assignments book for the course.  

## Meetup Format:
### Typically, these meetups will follow a standard format. One or more chapters will be covered in each meetup, and will be announced on the meetup page, so you have time to read over the material and do the in-text practice problems.  On meetup days, we will:
1. Review exercises or assignments from the previous meetup, and answer any questions about the material
2. Provide an outline of the material
3. Review the assigned chapters, with various exercises including fill in the blank and live coding
4. Break for practice problems
5. Discuss the assignment for the next meetup, which will be available on Runestone the day after the meetup, and which chapters we will cover at the next meetup


### The format for tonight will be slightly different, since we are still setting up the course and making sure everyone has access to the material.  Tonight, we will:
1. Briefly define terms and discuss what we'll learn with this series
2. Review basic Python to establish a baseline
3. Review a class in Python and discuss Object Oriented Progamming and Inheritance
4. Breakout for discussion questions and programming exercises 
5. Review of exercises
6. Chapters for next month, and next steps

# 1. Defining Terms, by the book:
### **Computer Science** - the study of problems, problem solving, and the solutions developed by the problem solving process
### **algorithm** - a step-by-step list of instructions for solving any instance of a problem that might arise. These processes must be finite.  If you follow the steps of an algorithm, then you will solve the problem.
### **computable** - a problem that can be solved with an algorithm
### **abstraction** - a separation of the logical and physical perspectives of a problem
### **programming** - the process of encoding an algorithm in a programming language so that it can be executed

### Although the computer can easily process data represented as strings of binary digits, humans cannot.  So, we have primitive data types built into Python for ease of use.

### Sometimes, these primitive data types are insufficient or inefficient for more complex problems or data.  When the primitive data types aren't sufficient, we will need to use data structures  
### **abstract data types** - a logical description of how we view data and allowed operations without regard for how it will be implemented.
### **data structures** - an implementation of an abstract data type

### Ultimately, our goal will be to learn how to efficiently solve computable problems using Python.  This requires both an understanding of different algorithms, and also a strong grasp on the way that Python works.  We will gain proficiency in Python largely by practice.  There are coding section in the textbook; take advantage of those, and do as many of the practice problems as you are able.  Many of the examples we use during the meetup come from sites like leet code, hacker rank, or code wars.  Some people also find it helpful to join a similar site to get daily or weekly reminder emails to practice.

# 2. Python Review
### Primitive data types in python:

1. integer - a whole number, i.e `-2`, `17`
2. float - a decimal number, i.e `6.72`
3. strings - containing 0 or more characters or spaces, surrounded by quotes, i.e `''`, `'hello, there'`
4. boolean - either `True` or `False`

### You can assign a value to a variable by using  the assignment operator `=`
`my_variable = 17`

creates a variable named my_variable that is assigned to the int value 17.
"""

# code break - Create a variable called test and assign it to the String "TEST"
test = "TEST"
print(test)

"""### Any mathematical operator may be used in Python, and note that operator precedence will follow the mathematical order of operations (PEMDAS)
### There are also a some relational and logical operators that are extremely useful to know:
**Operation Name** | **Operator** | **Explaination**
-|-|-
less than | < | less than operator
greater than | > | greater than operator
less than or equal to | <= | less than 
greater than or equal to | >= | greater
equal | == | equality operator
not equal | != | non equal operator
logical and | `and` | Both operands True for result to be True
logical or | `or` | One or the other operand is True for the result to be True
logical not | `not` | Negates the truth value, False becomes True, True becomes False
"""

5 == 10

# code test - write an expression that evaluates to True using the not equal operator
10 == 10

my_list = ['a', 'b', 'c']
my_list.append('d')
print(my_list)

"""### Python Built in data Structures

### Sequences:
#### 1. lists - notated with `[]` with elements separated by commas, a list can contain any number of elements of any type. mutable - new elements can be inserted and existing elements can be removed easily. sequential - lists are ordered, and can be accessed by numbered index  
`my_list = ['a', 'b', 'c']`  

Method Name | Use | Explanation
-|-|-
append|alist.append(item)|Adds a new item to the end of a list
insert|alist.insert(i,item)|Inserts an item at the ith position in a list
pop|alist.pop()|Removes and returns the last item in a list
pop|alist.pop(i)|Removes and returns the ith item in a list
sort|alist.sort()|Modifies a list to be sorted
reverse|alist.reverse()|Modifies a list to be in reverse order
del|del alist[i]|Deletes the item in the ith position
index|alist.index(item)|Returns the index of the first occurrence of item
count|alist.count(item)|Returns the number of occurrences of item
remove|alist.remove(item)|Removes the first occurrence of item  


#### 2. tuples - notated with `()`, with elements separated by commas, tuples can contain any number of elements of any type.  immutable - once created, new elements cannot be added or removed, and you cannot shift elements around. sequential - tuples are ordered, and can be accessed by numbered index  
`('a', 'b', 'c')`

This table lists the sequence operations sorted in ascending priority. In the table, s and t are sequences of the same type, n, i, j and k are integers and x is an arbitrary object that meets any type and value restrictions imposed by s.

Operation | Result |
-|-
x in s| True if an item of s is equal to x, else False
x not in s | False if an item of s is equal to x, else True
s + t|the concatenation of s and t
s * n or n * s|equivalent to adding s to itself n times
s[i]| ith item of s, origin 0
s[i:j]|slice of s from i to j
s[i:j:k]|slice of s from i to j with step k
len(s)|length of s
min(s)|smallest item of s
max(s)|largest item of s
s.index(x[, i[, j]])|index of the first occurrence of x in s (at or after index i and before index j)
s.count(x)|total number of occurrences of x in s

#### 3. sets - notated with `{}`, with elements separated by commas, sets are an unordered collection of unique elements.  
`{'jack', 'sjoerd'}`

#### 4. dictionaries - notated with `{}`, with key and value separated by a colon, and pairs separated by commas, an unordered mapping of key and value pairs  
`MLB_teams = {'Colorado' : 'Rockies', 'Boston'   : 'Red Sox', 'Minnesota': 'Twins', 'Milwaukee': 'Brewers', 'Seattle'  : 'Mariners'}`
"""

# Code Break - create a list called shapes and assign it the values 'circle', 'square', and 'triangle'. add at least two additional shapes,
# then remove circle from the list and print the resulting list.
shapes = ["circle", "square", "triangle"]
shapes.append("rectangle")
shapes.append("pentagon")
del(shapes[0])
print(shapes)

"""### Control structures:
### `while:` - while the condition is met, the code will execute.  when the condition is false
"""

counter = 1
while counter <= 5:
     print("Hello, world")
     counter = counter + 1

"""### `for:` - iterates over the elements of an object and executes the indented code for each element; can be nested"""

for item in range(5):
    print(item**2)

"""### `if, else` - executes code depending on a condition; can be nested"""

# set the value of n and run the code
import math
n = 42

if n<0:
   print("Sorry, value is negative")
else:
   print(math.sqrt(n))

# code break - modify the code to output only unique characters
wordlist = ['cat','dog','rabbit']
letterlist = [ ]
for aword in wordlist:
    for aletter in aword:
        letterlist.append(aletter)
print(letterlist)

wordlist = ['cat','dog','rabbit']
letterlist = [ ]
for aword in wordlist:
    for aletter in aword:
      if not aletter in letterlist:
        letterlist.append(aletter)
print(letterlist)

"""# The Fraction Class
With this example, our goal is to create data objects that “look like” fractions.

Our fraction class will allow for the two parts of a fraction - the numerator, which can be any integer, and the denominator, which can be any integer greater than 0.

The operations for the Fraction type will allow a Fraction data object to behave like any other numeric value. We need to be able to add, subtract, multiply, and divide fractions. We also want to be able to show fractions using the standard “slash” form, for example 2/3. In addition, all fraction methods should return results in their lowest terms so that no matter what computation is performed, we always end up with the most common form.

In Python, we define a new class by providing a name and a set of method definitions that are syntactically similar to function definitions. For this example:
"""

class Fraction:

    def __init__(self,top,bottom):

        self.num = top
        self.den = bottom

"""### Now that we have the class and the constructor set up, let's create an instance of the class and then print it"""

myfraction = Fraction(2,3)

print(myfraction)

"""### The output of the print statement looks funky, but we didn't tell the fraction object how to respond to this request to print. The print function requires that an object convert itself into a string so that the string can be written to the output. In this case, the Fraction object doesn't knw how to do that so instead it prints the actual reference that is stored in the variable (the address itself).

### We can either define a method to allow the Fraction object to print itself as a string, in this case the `show` method, or we can override the existing method to return a string from the object. The __str__ method is used to convert an object into a string. The default implementation for this method is to return the instance address string as we have already seen.  To override it, we use the same method name, and change the return string to give use the data we want
"""

class FractionShow:

    def show(self):
        print(self.num,"/",self.den)

    def __init__(self,top,bottom):

        self.num = top
        self.den = bottom

"""### If we used the `show` method, instead of `print(my_fraction)`, we could:"""

my_fraction = FractionShow(1, 7)
my_fraction.show()

"""### If we overrode the `__str__` method:"""

class FractionOver:

    def __init__(self,top,bottom):

        self.num = top
        self.den = bottom

    def __str__(self):
        return str(self.num)+"/"+str(self.den)

myf = FractionOver(3,4)
print(myf)

"""### Now, let's try to implement an addition method.  Update the Fraction class with a method that overrides the addition method. In Python, this method is called __add__ and it requires two parameters. The first, self, is always needed, and the second represents the other operand in the expression.

### Since two fractions must have the same denominator to be added, it is easiest to simply use the product of the two denominators as a common denominator.  See the code below
"""

class Fraction:

    def __init__(self,top,bottom):

        self.num = top
        self.den = bottom

    def __str__(self):
        return str(self.num)+"/"+str(self.den)

    def __add__(self,otherfraction):

        newnum = self.num*otherfraction.den + self.den*otherfraction.num
        newden = self.den * otherfraction.den

        return Fraction(newnum,newden)

f1 = Fraction(1, 4)
f2 = Fraction(1, 2)
f3 = f1 + f2
print(f3)

"""### This is functional, but remember that a requirement of the class was to represent the Fraction as the simplest possible form, and 6/8 is not the simplest form. So, we need a helper function to look for the greatest common divisor, or GCD. We can then divide the numerator and the denominator by the GCD and the result will be reduced to lowest terms.

### The best-known algorithm for finding a greatest common divisor is Euclid’s Algorithm, which will be discussed in detail in Chapter 8. Euclid’s Algorithm states that the greatest common divisor of two integers m and n is n if n divides m evenly. However, if n does not divide m evenly, then the answer is the greatest common divisor of n and the remainder of m divided by n. Note that this implementation of the GCD algorithm only works when the denominator is positive. This is acceptable for our fraction class because we have said that a negative fraction will be represented by a negative numerator.
"""



def gcd(m,n):
    while m%n != 0:
        oldm = m
        oldn = n

        m = oldn
        n = oldm%oldn
    return n

class Fraction:

    def __init__(self,top,bottom):

        self.num = top
        self.den = bottom

    def __str__(self):
        return str(self.num)+"/"+str(self.den)

    def __add__(self,otherfraction):
        newnum = self.num*otherfraction.den + self.den*otherfraction.num
        newden = self.den * otherfraction.den
        common = gcd(newnum,newden)
        return Fraction(newnum//common,newden//common)

f1 = Fraction(1, 4)
f2 = Fraction(1, 2)
f3 = f1 + f2
print(f3)

"""### Now that we've seen how to override the built in methods, let's take a break to practice by overriding the `__sub__` method"""

# Code challenge: how can you override the subtraction method so that it returns the result of fraction subtraction and simplified fractions?

def gcd(m,n):
    while m%n != 0:
        oldm = m
        oldn = n

        m = oldn
        n = oldm%oldn
    return n

class Fraction:
     def __init__(self,top,bottom):
         self.num = top
         self.den = bottom

     def __str__(self):
         return str(self.num)+"/"+str(self.den)

     def show(self):
         print(self.num,"/",self.den)

     def __add__(self,otherfraction):
         newnum = self.num*otherfraction.den + \
                      self.den*otherfraction.num
         newden = self.den * otherfraction.den
         common = gcd(newnum,newden)
         return Fraction(newnum//common,newden//common)

     def __sub__(self,otherfraction):
         newnum = self.num*otherfraction.den - \
                      self.den*otherfraction.num
         newden = self.den * otherfraction.den
         common = gcd(newnum,newden)
         return Fraction(newnum//common,newden//common)


     def __eq__(self, other):
         firstnum = self.num * other.den
         secondnum = other.num * self.den

         return firstnum == secondnum

x = Fraction(1,2)
y = Fraction(2,3)
print(x+y)
print(x == y)
print(x-y)

"""# Inheritance
### **Inheritance** - the ability for one class to be related to another class in much the same way that people can be related to one another. child classes can inherit characteristic data and behavior from a parent class. These classes are often referred to as subclasses and superclasses.

### The Python `Collections` class is the parent class of the `Sequential Collections` and `Non-Sequential Collections` classes.  The `Sequential Collections` class is the parent of the `lists` and `tuples` classes.

### Lists, tuples, and strings are all types of sequential collections. They all inherit common data organization and operations. However, each of them is distinct based on whether the data is homogeneous and whether the collection is immutable. The children all gain from their parents but distinguish themselves by adding additional characteristics.

### By organizing classes in this hierarchical fashion, object-oriented programming languages allow previously written code to be extended to meet the needs of a new situation. In addition, by organizing data in this hierarchical manner, we can better understand the relationships that exist. We can be more efficient in building our abstract representations.

# For next time:
### Try out these coding exercises, and also look check the runestone course next week for an official assignment that will allow you to check your answers.  
### Read chapters 2 and 3, and review any Python concepts that my be fuzzy.  Ask any questions you may have in either the WWC or PyLadies slack
"""

# Create a function that accepts a string, and determines if that string contains repeated letters or not.

# There is a data structure in Python that is commonly used to implement a queue.  Which is it?  Why is it often used?

# create a function that accepts a string, and determines if that string contains a substring

"""### Notable resources - 
### https://onlinejudge.org/ - programming problems with robot judging, but you need to create an account
### https://projecteuler.net/ - challenging and interesting math/computing problems
"""
